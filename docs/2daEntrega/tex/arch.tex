\section{Arquitectura}

El Main será simplemente una vista de WordService que es el backend de la aplicación y quien brinda todos los servicios a la vista. Estos servicios son 3:
\begin{enumerate}
\item Agregar un Documento.
\item Realizar una búsqueda.
\item Reproducir un Documento.
\end{enumerate}

Veamos la arquitectura parte por parte. Pero antes definamos el concepto de Documento, que es común a todas las partes.

\subsection{Documento}

Es una interfaz que permite manejar un documento obteniendo de él renglones.
Posee tres implementaciones, una que contiene un documento totalmente en memoria, otra que trabaja con un archivo que lee desde disco a medida que va necesitándolo, y otra que trabaja con los documentos prealmacenados que obtiene de forma \textit{lazy}.

Ahora si, veamos la arquitectura de cada una de las partes antes mencionadas.

\subsection{-1- Agregar un Documento}

Se divide en divide en 2 grandes partes:
\renewcommand{\labelenumi}{\alph{enumi}.}
\begin{enumerate}
\item Agregarlo al indice.
\item Agregarlo al diccionario de sonidos.
\end{enumerate}

Existe una característica en común entre estas dos partes: el parseo. Es por eso que la arquitectura se definió de tal forma que el parseo se haga en una sola oportunidad como se mostrará luego (esto tiene una pequeña consecuencia que se mencionará al explicar la adición al diccionario de sonidos).

\subsubsection{-a- Agregar un Documento al indice}


Quien se encarga de realizar esto es el \textit{Crawler}, quien recibirá un \textit{Documento}. En primer lugar le pasa el documento al \textit{Parser} que lo utilizará como fuente para datos.

El Parser permite manejar un documento en forma de \textit{Frases}, entendiendo por tal a un conjunto de palabras separadas por un signo de puntuación (\textit{'.', ',', ';', '?', '!'}, etc.). A estas frases les aplicará un reemplazo de símbolos diacríticos, retiro de símbolos extraños, símbolos numéricos, etc, y case folding, obteniendo por resultado una lista de palabras limpia. De esta manera el \textit{Crawler} puede obtener \textit{Frases} limpias desde el parser al que inicialmente le pasa el documento como fuente.

La colección de palabras obtenida será procesada por el módulo \textit{StopWords Discriminator}, cuya implementación tendrá un listado en memoria (que levanta al iniciar la aplicación desde un archivo) de frases y de palabras sueltas que son stop words para hacer el procesamiento.

El \textit{Crawler} obtiene del \textit{StopWords Discriminator} una colección (ordenada o desordenada, no importa, pero con repeticiones, si importa) de palabras que no contienen stop words. Esta colección (correspondiente a una sola \textit{Frase}) le será entregada al \textit{Indexer}.

El \textit{Indexer} es la interfaz utilizada para acceder al índice (un \textit{Árbol b\#}) (también podría haberselo llamado Index en vez de Indexer). El \textit{Crawler} maneja una session con el \textit{Indexer}, que comienza al procesar un \textit{Documento} y termina al agregar la última \textit{Frase} (cuando el \textit{Parser} deja de brindarle datos). El \textit{Indexer} parametriza un \textit{BTree\#}, un módulo que maneja un árbol b\# de manera genérica. El \textit{Indexer} a su vez maneja una session idéntica a la que tiene con el \textit{Crawler} con el módulo \textit{Inversion Sort Handler}, y solo agregará las palabras al árbol una vez que el \textit{Crawler} finalice la session con el \textit{Indexer}.

El \textit{BTree\#} es una implementación genérica de árbol b\# que utiliza 2 archivos, uno para nodos internos y otro para hojas, y que maneja una equiparación entre nodos y bloques. Utiliza el \textit{VariableLengthFileManager} en su implementación en disco. Debe ser parametrizado con una \textit{Key} (clave de los nodos internos) y un \textit{Element} (registro de las hojas que contiene entre otras cosas a la clave). Este \textit{Element} se definirá de tal manera que tenga el listado de \textit{Documentos} en su interior; este listado de \textit{Documentos} se implementará utilizado el \textit{VariableLengthFileManager}. No se muestra a \textit{Key} ni a \textit{Element}, ni al archivo del listado de \textit{Documentos} en el diagrama por simplificación. Además deben brindarse los \textit{Serializer} correspondientes a una colección ordenada de \textit{Keys} y de \textit{Elements} para parametrizar al \textit{BTree\#}.

Las sessiones mencionadas (entre el \textit{Crawler} y \textit{Indexer}, y entre el \textit{Indexer} y el \textit{Inversion Sort Handler}) sirven para evitar tener un documento completo en memoria.

Al mismo tiempo que el \textit{Crawler} va procesando las frases, va a agregando todas las palabras encontradas en un Set (conjunto sin repeticiones), de esta manera obtiene el vocabulario completo. Ese Set será devuelto al \textit{WordService} como respuesta al pedido de indexar un documento.

\subsubsection{-b- Agregar un Documento al diccionario de sonidos =-}


Como puede adivinarse, el vocabulario completo obtenido al agregar un docuemento al índice es la entrada usada para realizar el agregado al diccionario de sonidos. Esto tiene como consecuencia que el agregado de sonidos será en distinto orden al original del documento. Pero tiene como ventaja el no tener que procesar dos veces el documento por el \textit{Parser} (y a no tener que leerlo de nuevo desde disco si es que no se lo quiere tener completo en memoria como planteamos antes).

El módulo usado para esta acción es el llamado \textit{WordsRecorder}.

Si bien se modificó levemente la interacción entre los módulos, la arquitectura es básicamente la misma que para la entrega 1, y la interacción entre módulos puede verse claramente en el esquema.

La única gran modificación consiste en el reemplazo del "índice secuencial de sonidos" por un \textit{Trie}, que utiliza para su implementación un \textit{VariableLengthFileManager}.

\subsection{-2- Realizar una Búsqueda}

Esta acción es responsabilidad del \textit{Search Engine}. Para hacerlo primero debe limpiar la cadena de búsqueda, para lo cual interactura con el \textit{Parser} y con el \textit{StopWords Discriminator}.
Una vez que tiene la consulta limpia, realiza la búsqueda utilizando el \textit{Indexer}, que a su vez utilizará el \textit{BTree\#}.

El \textit{SearchEngine} realiza las operaciones de ordenado necesarias y devuelve un listado ordenado de \textit{documentos}.

\subsection{-3- Reproducir un Documento}

La reproducción la realizará el \textit{DocumentPlayer}, que recibirá un \textit{Documento} que deberá parsear utilizando el \textit{Parser}. A medida que va obteniendo las palabras correspondientes las irá reproduciendo delegando toda la complejidad en el \textit{WordsPlayer}.

El \textit{WordsPlayer} es la contrapartida del \textit{WordsRecorder} explicado antes, y su arquitectura es coincidente con la de este.

\subsection{Otros datos relevantes de la arquitectura}

Se definió una abstracción de manejo de registros de longitud variable llamada \textit{StraightVariableLengthFile}. La misma solo permite agregado, sin actualizaciones. Se incorporó esta abstracción al archivo de sonidos (que antes era un \textit{VariableLengthFileManager}) por lo que ahora el archivo correspondiente es 100\% denso. Además fue usado en otras partes que lo requerían como puede verse en el diagrama.

El \textit{VariableLengthFileManager} que ya existía en la entrega anterior, ahora permite actualizaciones de los registros.

\begin{figure}[!htp]
	\begin{center}
		\includegraphics[scale=0.5,natwidth=20pt,natheight=10pt]{img/Arch2daEntrega.png}
	\end{center}
	\caption{Arquitectura VariableLengthFileManager} 
\end{figure}

\begin{figure}[!htp]
	\begin{center}
		\includegraphics[scale=0.5,natwidth=20pt,natheight=10pt]{img/VariableLengthFileManager.png}
	\end{center}
	\caption{Arquitectura VariableLengthFileManager} 
\end{figure}
