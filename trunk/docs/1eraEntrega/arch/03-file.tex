\section{Manejadores de Archivo}

Los datos que manejara **The Speaker** tenían, como requerimiento técnico, que ser persistidos en dos archivos separados y debían utilizar la siguiente estructura lógica.
\begin{enumerate}
	\item \texttt{((palabra)i, offset)}
	\item \texttt{(stream de audio)}
\end{enumerate}
El primero está compuesto de la dupla palabra (que es un identificador) y offset/referencia. Simbolizando que para la {\it palabra} el audio se encuentra en {\it referencia}.
El segundo archivo contiene los streams de audio capturados.

\subsection{Análisis}
Lo primero que se observa de ambos archivos es que sus registros son de longitud variable y que hay homogeneidad en los datos a almacenar, es decir, que en cada archivo se almacenan siempre los mismos tipos de datos. De manera que, ambos archivos, a pesar de tener naturalezas de datos diferentes requieren el mismo manejo. Por lo cual, admiten una misma solución de manejo del archivo mientras que la misma se mantenga indepen de la naturaleza de los datos a almacenar. 

Por otra parte, las operaciones que se deben permitir son el agregado de registros y la consulta de los mismos. El agregado de registros no requiere, en ninguno de los dos casos, que se haga con un orden específico. Mientras que la recuperación de los datos, por otra parte, en el primer archivo debe poder ser secuencial (ya que se necesitan poder acceder a cada una de las palabras) y en el segundo caso debe poder accederse directamente a un registro que conozco su posición dentro del archivo. Por lo cual, estamos ante una organización secuencial de acceso relativo. Pudiendo recorrerse tanto secuencialmente como acceder a un registro específico (si se conoce previamente su dirección).

\subsection{Solución propuesta}
\paragraph{}
Se utilizarán instancias de una clase llamada \textbf{VariableLengthFileManager} para abstraer a cada uno de los archivo. Esta clase define el comportamiento tanto, de la carga de registros, como de las dos formas diferentes de recuperación de registros (completa y secuencial, y, de un único registro y direccionada). 

Para que la misma clase pueda persistir archivos con registros de diferente naturaleza se implementaron los serializadores  {\textit{(ver sección \ref{sec:Serializadores}.)}}
El serializador es configurado en cada archivo a manejar y realiza las dos conversiones necesarias: 
\begin{itemize}
	\item la tira de bytes leida en un objeto (Mapeo)
	\item un objeto en una tira de bytes que será grabada (Serialización)
\end{itemize}

Esta clase no manejará directamente el acceso al archivo físico si no que delegará en un fino wrapper de la clase \textbf{RandomAccessFile} que se encargará del manejo de los datos en bloque. {\it Ver figura \ref{fig:classVLFM}.}

\begin{figure}[!htp]
	\includegraphics[scale=0.35,natwidth=40pt, natheight=20pt]{img/ClassDiagramVariableLengthFileManager.png}
	\caption{Diagrama de clases del \textbf{VariableLengthFileManager}} 
	\label{fig:classVLFM}
\end{figure}

\paragraph{}
El manejo de este archivo es simple, a medida que se le solicita agregar objetos los serializa con el serializador con que fue configurado y los agrega al último bloque (esto no significa que se escriba en este momento). Si se le solicita algún objeto en particular, mediante la dirección del mismo, este manejador de archivo accede al bloque que indique la dirección y mapea los datos del objeto correcto utilizando el mismo serializador.

\subsubsection[Operación de creación]{Agregado de registro}
\paragraph{}
El agregado de registros, como se mencionó anteriormente, primero serializa el objeto y luego lo agrega al último bloque. Este último bloque siempre se encuentra cacheado ya que se graba (o regraba) cuando esa caché, de último bloque, desborda, es decir, su tamaño supera el tamaño designado para datos del bloque. En ese momento se graban todos los registros que estaban en caché menos el último agregado. Si, este último agregado, tuviera un tamaño mayor al tamaño de designado para datos del bloque el mismo es dividido en n bloques y todos esos bloques son grabados.
{\it Ver figura \ref{fig:sequenceVLFM_add}.}
\begin{figure}[!htp]
	\begin{center}
		\includegraphics[scale=0.4,natwidth=20pt,natheight=10pt]{img/SequenceDiagramVLFM_add.png}
	\end{center}
	\caption{Diagrama de secuencia que muestra el agregado de un registro} 
	\label{fig:sequenceVLFM_add}
\end{figure}

\subsubsection[Operación de lectura secuencial]{Lectura de todos los datos}
\paragraph{}
Se implementó un iterador de todo el archivo que comienza en el bloque cero, mapea todos los datos de ese bloque a objetos y los va devolviendo de a uno. Luego de devolver todos los de ese bloque, pasa al siguiente bloque y realiza la misma operatori	a. Esto se repite hasta que no queden mas datos por hidratar. 
{\it Ver figura \ref{fig:sequenceVLFM_getAll}.}

\begin{figure}[!htp]
	\begin{center}
		\includegraphics[scale=0.4,natwidth=20pt,natheight=10pt]{img/SequenceDiagramVLFM_getAll.png}
	\end{center}
	\caption{Diagrama de secuencia que muestra la iteración sobre todos los registros} 
	\label{fig:sequenceVLFM_getAll}
\end{figure}

\subsubsection[Operación de lectura aleatoria]{Lectura de un objeto dada una dirección}
El manejador de archivo lee el bloque desde el archivo físico (excepto que el mismo esté en caché), y luego pasa los datos leidos por el serializador. Luego busca entre los objetos creados el que tenga la posición indicada por la dirección para poder devolverlo a quién se lo haya solicitado.
{\it Ver figura \ref{fig:sequenceVLFM_get}.}

\begin{figure}[!htp]
	\begin{center}
		\includegraphics[scale=0.4,natwidth=20pt, natheight=10pt]{img/SequenceDiagramVLFM_get.png}
	\end{center}
	\caption{Diagrama de secuencia que muestra la recuperación de un único registro} 
	\label{fig:sequenceVLFM_get}
\end{figure}

\subsection{Detalles técnicos}
Los bloques cuentan con la siguiente información de control. Los últimos 2 bytes indican (almacenado como un Short signado) la cantidad de registros enteros que posee el bloque (esto se utiliza al momento de hidratar, para no intentar hidratar mas registros de los que se encontraban almacenados), para el caso que el registro esté en múltiples bloques este valor se marca en cero y se toman los 8 bytes anteriores para indicar la posición del próximo bloque que contiene datos del mismo registro.

Se implementaron 2 cachés, muy básicas, la primera, ya fue mencionada, contiene el bloque actual donde se están agregando registros. La segunda contiene el último bloque leido del disco (para disminuir accesos a disco)


